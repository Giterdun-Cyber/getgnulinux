<?php
if ( !defined('GGL') ) {
    exit(1);
}

$this->load_header();
?>

<main>
  <article>
    <div class="container">
      <header>
        <h1><?php print _("GNU/Linux is not Windows"); ?></h1>
        <div class="page-intro">
          <p><?php print _("If you've been pointed at this page, then the chances are you're a relatively new GNU/Linux user who's having some problems making the switch from Windows to GNU/Linux. This causes many problems for many people, hence this article was written. Many individual issues arise from this single problem, so the page is broken down into multiple problem areas."); ?></p>
        </div>
      </header>

      <h2>Problem #1: GNU/Linux isn't exactly the same as Windows</h2>
      <p>You'd be amazed how many people make this complaint. They come to GNU/Linux, expecting to find essentially <a href="https://reactos.org/" rel="external">a free, open-source version of Windows</a>. Quite often, this is what they've been told to expect by over-zealous GNU/Linux users. However, it's a paradoxical hope.</p>
      <p>The specific reasons why people try GNU/Linux vary wildly, but the overall reason boils down to one thing: they hope GNU/Linux will be better than Windows. Common yardsticks for measuring success are cost, choice, performance, and security. There are many others. But every Windows user who tries GNU/Linux, does so because they hope it will be better than what they've got.</p>
      <p>Therein lies the problem.</p>
      <p>It is logically impossible for any thing to be better than any other thing whilst remaining completely identical to it. A perfect copy may be equal, but it can never surpass. So when you gave GNU/Linux a try in hopes that it would be better, you were inescapably hoping that it would be different. Too many people ignore this fact, and hold up every difference between the two operating systems as a GNU/Linux failure.</p>
      <p>As a simple example, consider driver upgrades: one typically upgrades a hardware driver on Windows by going to the manufacturer's website and downloading the new driver; whereas in GNU/Linux you upgrade the kernel.</p>
      <p>This means that a single GNU/Linux download and upgrade will give you the newest drivers available for your machine, whereas in Windows you would have to surf to multiple sites and download all the upgrades individually. It's a very different process, but it's certainly not a bad one. But many people complain because it's not what they're used to.</p>
      <p>Or, as an example you're more likely to relate to, consider Firefox: one of the biggest open-source success stories. A web browser that took the world by storm. Did it achieve this success by being a perfect imitation of Internet Explorer, the then-most-popular browser?</p>
      <p>No. It was successful because it was <em>better</em> than Internet Explorer, and it was <em>better</em> because it was <em>different</em>. It had tabbed browsing, live bookmarks, built-in searchbar, PNG support, adblock extensions, and other wonderful things. The <em>"Find"</em> functionality appeared in a toolbar at the bottom and looked for matches as you typed, turning red when you had no match. Internet Explorer had no tabs, no RSS functionality, searchbars only via third-party extensions, and a find dialogue that required a click on <em>"OK"</em> to start looking and a click on <em>"OK"</em> to clear the <em>"Not found" </em>error message. A clear and inarguable demonstration of an open-source application achieving success by being better, and being better by being different. Had Firefox been an Internet Explorer clone, it would have vanished into obscurity. And had GNU/Linux been a Windows clone, the same would have happened.</p>
      <p>So the solution to problem #1: remember that where GNU/Linux is familiar and the same as what you're used to, it <em>isn't</em> new and improved. Welcome the places where things are different, because only here does it have a chance to shine.</p>

      <h2>Problem #2: GNU/Linux is <em>too</em> different from Windows</h2>
      <p>The next issue arises when people do expect GNU/Linux to be different, but find that some differences are just too radical for their liking. Probably the biggest example of this is the sheer amount of choice available to GNU/Linux users. Whereas an out-of-the-box-Windows user has the Classic or XP desktop with Wordpad, Internet Explorer, and Outlook Express installed, an out-of-the-box-GNU/Linux user has hundreds of distributions to choose from, then Gnome or KDE or Fluxbox or whatever, with vi or emacs or kate, Konqueror or Opera or Firefox or Mozilla, and so on and so forth.</p>
      <p>A Windows user isn't used to making so many choices just to get up and running. Exasperated <i>"Does there have to be so much choice?"</i> posts are very common.</p>
      <p><em>Does</em> GNU/Linux really have to be so different from Windows? After all, they're both operating systems. They both do the same job: power your computer and give you something to run applications on. Surely they should be more or less identical?</p>
      <p>Look at it this way: step outside and take a look at all the different vehicles driving along the road. These are all vehicles designed with more or less the same purpose: to get you from A to B via the roads. Note the variety in designs.</p>
      <p>But, you may be thinking, car differences are really quite minor: they all have a steering wheel, foot-pedal controls, a gear stick, a handbrake, windows and doors... If you can drive one car, you can drive any car!</p>
      <p>Quite true. But did you not see that some people weren't driving cars, but were riding motorbikes instead?</p>
      <p>Switching from one version of Windows to another is like switching from one car to another. Windows 95 to Windows 98, I honestly couldn't tell the difference. Windows 98 to Windows XP, it was a bigger change but really nothing major.</p>
      <p>But switching from Windows to GNU/Linux is like switching from a car to a motorbike. They may both be <strong>operating systems/road vehicles</strong>. They may both use the same <strong>hardware/roads</strong>. They may both <strong>provide an environment for you to run applications/transport you from A to B</strong>. But they use fundamentally different approaches to do so.</p>
      <p><strong>Windows/cars</strong> are not safe from <strong>viruses/theft</strong> unless you <strong>install an antivirus/lock the doors</strong>. <strong>GNU/Linux/motorbikes</strong> don't have <strong>viruses/doors</strong>, so are perfectly safe without you having to <strong>install an antivirus/lock any doors</strong>.</p>
      <p>Or look at it the other way round:</p>
      <p><strong>GNU/Linux/cars</strong> were designed from the ground up for multiple <strong>users/passengers</strong>. <strong>Windows/motorbikes</strong> were designed for one <strong>user/passenger</strong>. Every <strong>Windows user/motorbike driver</strong> is used to being in full control of his <strong>computer/vehicle</strong> at all times. A <strong>GNU/Linux user/car passenger</strong> is used to only being in control of his <strong>computer/vehicle</strong> when <strong>logged in as root/sitting in the driver's seat</strong>.</p>
      <p>Two different approaches to fulfilling the same goal. They differ in fundamental ways. They have different strengths and weaknesses: a car is the clear winner at transporting a family and a lot of cargo from A to B. More seats and more storage space. A motorbike is the clear winner at getting one person from A to B. Less affected by congestion and uses less fuel.</p>
      <p>There are many things that <em>don't</em> change when you switch between cars and motorbikes: you still have to put petrol in the tank or charge the battery, you still have to drive on the same roads, you still have to obey the traffic lights and Stop signs, you still have to indicate before turning, you still have to obey the same speed limits.</p>
      <p>But there are also many things that <em>do</em> change: car drivers don't have to wear crash helmets, motorbike drivers don't have to put on a seatbelt. Car drivers have to turn the steering wheel to get around a corner, motorbike drivers have to lean over. Car drivers accelerate by pushing a foot-pedal, motorbike drivers accelerate by twisting a hand control.</p>
      <p>A motorbike driver who tries to corner a car by leaning over is going to run into problems very quickly. And Windows users who try to use <em>their</em> existing skills and habits generally also find themselves having many issues. In fact, Windows "power users" frequently have <em>more</em> problems with GNU/Linux than people with little or no computer experience, for this very reason. Typically, the most vehement <i>"GNU/Linux is not ready for the desktop yet"</i> arguments come from ingrained Windows users who reason that if <em>they</em> couldn't make the switch, a less-experienced user has no chance. But this is the exact opposite of the truth.</p>
      <p>So, to avoid problem #2: don't assume that being a knowledgeable Windows user means you're a knowledgeable GNU/Linux user. When you first start with GNU/Linux, you are a novice.</p>

      <h2>Problem #3: Culture shock</h2>
      <h3>Subproblem #3a: There <em>is</em> a culture</h3>
      <p>Windows users are more or less in a customer-supplier relationship: they pay for software, for warranties, for support, and so on. They expect software to have a certain level of usability. They are therefore used to having rights with their software: they have paid for technical support and have every right to demand that they receive it. They are also used to dealing with entities rather than people: their contracts are with a company, not with a person.</p>
      <p>GNU/Linux users are in more of a community. They don't have to buy the software, they don't have to pay for technical support. They download software for free and use Instant Messaging and web-based forums to get help. They deal with people, not corporations.</p>
      <p>A Windows user will not endear himself by bringing his habitual attitudes over to GNU/Linux, to put it mildly.</p>
      <p>The biggest cause of friction tends to be in the online interactions: a "3a" user new to GNU/Linux asks for help with a problem he's having. When he doesn't get that help at what he considers an acceptable rate, he starts complaining and demanding more help. Because that's what he's used to doing with paid-for tech support. The problem is that this <em>isn't</em> paid-for support. This is a bunch of volunteers who are willing to help people with problems out of the goodness of their hearts. The new user has no right to demand anything from them, any more than somebody collecting for charity can demand larger donations from contributors.</p>
      <p>In much the same way, a Windows user is used to using commercial software. Companies don't release software until it's reliable, functional, and user-friendly enough. So this is what a Windows user tends to expect from software: it starts at version 1.0. GNU/Linux software, however, tends to get released almost as soon as it's written: it starts at version 0.1. This way, people who really need the functionality can get it ASAP; interested developers can get involved in helping improve the code; and the community as a whole stays aware of what's going on.</p>
      <p>If a "3a" user runs into trouble with GNU/Linux, he'll complain: the software hasn't met his standards, and he thinks he has a right to expect that standard. His mood won't be improved when he gets sarcastic replies like <i>"I'd demand a refund if I were you"</i>.</p>
      <p>So, to avoid problem #3a: simply remember that you haven't paid the developer who wrote the software or the people online who provide the tech support. They don't owe you anything.</p>

      <h3>Subproblem #3b: New vs. Old</h3>
      <p>GNU/Linux pretty much started out life as a hacker's hobby. It grew as it attracted more hobbyist hackers. It was quite some time before anybody but a geek stood a chance of getting a useable GNU/Linux installation working easily. GNU/Linux started out <i>"By geeks, for geeks."</i> And even today, the majority of established GNU/Linux users are self-confessed geeks.</p>
      <p>And that's a pretty good thing: if you've got a problem with hardware or software, having a large number of geeks available to work on the solution is a definite plus.</p>
      <p>But GNU/Linux has grown up quite a bit since its early days. There are distributions that almost anybody can install, even distributions that live on CDs or USB sticks and detect all your hardware for you without <em>any</em> intervention. It's become attractive to non-hobbyist users who are just interested in it because it's virus-free and cheap to upgrade. It's not uncommon for there to be friction between the two camps. It's important to bear in mind, however, that there's no real malice on either side: it's lack of understanding that causes the problems.</p>
      <p>Firstly, you get the hard-core geeks who still assume that everybody using GNU/Linux is a fellow geek. This means they expect a high level of knowledge, and often leads to accusations of arrogance, elitism, and rudeness. And in truth, sometimes that's what it is. But quite often, it's not: it's elitist to say <i>"Everybody ought to know this"</i>. It's not elitist to say <em>"Everybody knows this"</em> - quite the opposite.</p>
      <p>Secondly, you get the new users who're trying to make the switch after a lifetime of using commercial operating systems. These users are used to software that anybody can sit down and use, out-of-the-box.</p>
      <p>The issues arise because group 1 is made up of people who enjoy being able to tear their operating system apart and rebuild it the way they like it, while group 2 tends to be indifferent to the way the operating system works, so long as it <em>does</em> work.</p>
      <p>A parallel situation that can emphasize the problems is Lego. Picture the following:</p>
      <blockquote><strong>New:</strong><br>I wanted a new toy car, and everybody's raving about how great Lego cars can be. So I bought some Lego, but when I got home, I just had a load of bricks and cogs and stuff in the box. Where's my car?</blockquote>
      <blockquote><strong>Old:</strong><br>You have to build the car out of the bricks. That's the whole point of Lego.</blockquote>
      <blockquote><strong>New:</strong><br>What? I don't know how to build a car. I'm not a mechanic. How am I supposed to know how to put it all together?</blockquote>
      <blockquote><strong>Old:</strong><br>There's a leaflet that came in the box. It tells you exactly how to put the bricks together to get a toy car. You don't need to know how, you just need to follow the instructions.</blockquote>
      <blockquote><strong>New:</strong><br>Okay, I found the instructions. It's going to take me hours! Why can't they just sell it as a toy car, instead of making you have to build it?</blockquote>
      <blockquote><strong>Old:</strong><br>Because not everybody wants to make a toy car with Lego. It can be made into anything we like. That's the whole point.</blockquote>
      <blockquote><strong>New:</strong><br>I still don't see why they can't supply it as a car so people who want a car have got one, and other people can take it apart if they want to. Anyway, I finally got it put together, but some bits come off occasionally. What do I do about this?  Can I glue it?</blockquote>
      <blockquote><strong>Old:</strong><br>It's Lego. It's designed to come apart. That's the whole point.</blockquote>
      <blockquote><strong>New:</strong><br>But I don't <em>want</em> it to come apart. I just want a toy car!</blockquote>
      <blockquote><strong>Old:</strong><br><em>Then why on Earth did you buy a box of Lego?</em></blockquote>
      <p>It's clear to just about anybody that Lego is not really aimed at people who just want a toy car. You don't get conversations like the above in real life. The whole point of Lego is that you have fun building it and you can make anything you like with it. If you've no interest in building anything, Lego's not for you. This is quite obvious.</p>
      <p>As far as the long-time GNU/Linux user is concerned, the same holds true for GNU/Linux: it's an open-source, fully-customizeable set of software. That's the whole point. If you don't want to hack the components a bit, why bother to use it?</p>
      <p>But there's been a lot of effort lately to make GNU/Linux more suitable for the non-hackers, a situation that's not a million miles away from selling pre-assembled Lego kits, in order to make it appeal to a wider audience. Hence you get conversations that aren't far away from the ones above: newcomers complain about the existence of what the established users consider to be fundamental features, and resent having the read a manual to get something working. But complaining that there are too many distributions; or that software has too many configuration options; or that it doesn't work perfectly out-of-the-box; is like complaining that Lego can be made into too many models, and not liking the fact that it can be broken down into bricks and built into many other things.</p>
      <p>So, to avoid problem #3b: just remember that what GNU/Linux seems to be now is <em>not</em> what GNU/Linux was in the past. The largest and most necessary part of the GNU/Linux community, the hackers and the developers, like GNU/Linux <em>because</em> they can fit it together the way they like; they don't like it in <em>spite</em> of having to do all the assembly before they can use it.</p>

      <h2>Problem #4: Designed for the designer</h2>
      <p>In the car industry, you'll very rarely find that the person who designed the engine also designed the car interior: it calls for totally different skills. Nobody wants an engine that only <em>looks</em> like it can go fast, and nobody wants an interior that works superbly but is cramped and ugly. And in the same way, in the software industry, the user interface (UI) is not usually created by the people who wrote the software.</p>
      <p>In the GNU/Linux world, however, this is not so much the case: projects frequently start out as one man's toy. He does everything himself, and therefore the interface has no need of any kind of <em>"user friendly"</em> features: the user knows everything there is to know about the software, he doesn't need help. Vi is a good example of software deliberately created for a user who already knows how it works: it's not unheard of for new users to reboot their computers because they couldn't figure out how else to get out of vi.</p>
      <p>However, there is an important difference between a Free and Open Source Software (FOSS) programmer and most commercial software writers: the software a FOSS programmer creates is software that he intends to use. So whilst the end result might not be as "comfortable" for the novice user, they can draw some comfort in knowing that the software is designed by somebody who knows what the end-users needs are: he too is an end-user. This is very different from commercial software writers, who are making software for <em>other people</em> to use: they are <em>not</em> knowledgeable end-users.</p>
      <p>So whilst vi has an interface that is hideously unfriendly to new users, it is still in use today because it is such a superb interface once you know how it works. Firefox was created by people who regularly browse the Web. The Gimp was built by people who use it to manipulate graphics files. And so on.</p>
      <p>So GNU/Linux interfaces are frequently a bit of a minefield for the novice: despite its popularity, vi should never be considered by a new user who just wants to quickly make a few changes to a file. And if you're using software early in its lifecycle, a polished, user-friendly interface is something you're likely to find only in the <em>"ToDo"</em> list: functionality comes first. Nobody designs a killer interface and then tries to add functionality bit by bit. They create functionality, and then improve the interface bit by bit.</p>
      <p>So to avoid #4 issues: look for software that's specifically aimed at being easy for new users to use, or accept that some software that has a steeper learning curve than you're used to. To complain that vi isn't friendly enough for new users is to be laughed at for missing the point.</p>

      <h2>Problem #5: The myth of "user-friendly"</h2>
      <p>This is a big one. It's a very big term in the computing world, "user-friendly". It's even the name of a particularly good webcomic. But it's a bad term.</p>
      <p>The basic concept is good: that software be designed with the needs of the user in mind. But it's always addressed as a single concept, which it isn't.</p>
      <p>If you spend your entire life processing text files, your ideal software will be fast and powerful, enabling you to do the maximum amount of work for the minimum amount of effort. Simple keyboard shortcuts and mouseless operation will be of vital importance.</p>
      <p>But if you very rarely edit text files, and you just want to write an occasional letter, the last thing you want is to struggle with learning keyboard shortcuts. Well-organized menus and clear icons in toolbars will be your ideal.</p>
      <p>Clearly, software designed around the needs of the first user will not be suitable for the second, and vice versa. So how can any software be called "user-friendly", if we all have different needs?</p>
      <p>The simple answer: user-friendly is a misnomer, and one that makes a complex situation seem simple.</p>
      <p>What does "user-friendly" really mean? Well, in the context in which it is used, "user friendly" software means <i>"Software that can be used to a reasonable level of competence by a user with no previous experience of the software"</i>. This has the unfortunate effect of making lousy-but-familiar interfaces fall into the category of "user-friendly".</p>

      <h3>Subproblem #5a: Familiar is friendly</h3>
      <p>So it is that in most "user-friendly" text editors and word processors, you Cut and Paste by using Ctrl-X and Ctrl-V. Totally unintuitive, but everybody's used to these combinations, so they count as a "friendly" combination.</p>
      <p>So when somebody comes to vi and finds that it's "d" to cut, and "p" to paste, it's not considered friendly: it's not what anybody is used to.</p>
      <p>Is it superior? Well, actually, yes.</p>
      <p>With the Ctrl-X approach, how do you cut a word from the document you're currently in? <em>(No using the mouse!)</em></p>
      <p>From the start of the word, <em>Ctrl-Shift-Right</em> to select the word.</p>
      <p>Then Ctrl-X to cut it.</p>
      <p>The vi approach? <em>dw</em> deletes the word.</p>
      <p>How about cutting <strong>five</strong> words with a Ctrl-X application?</p>

      <p> From the start of the words,</p>

      <em>Ctrl-Shift-Right</em><br>
      <em>Ctrl-Shift-</em><i>Right</i><br>
      <em>Ctrl-Shift-</em><i>Right</i><br>
      <em>Ctrl-Shift-</em><i>Right</i><br>
      <em>Ctrl-Shift-</em><i>Right</i><br>
      <em>Ctrl-X</em>

      <p>And with vi?</p>
      <p><em>d5w</em></p>
      <p>The vi approach is far more versatile and actually more intuitive: "X" and "V" are not obvious or memorable "Cut" and "Paste" commands, whereas "dw" to <strong>d</strong>elete a <strong>w</strong>ord, and "p" to <strong>p</strong>ut it back is perfectly straightforward. But "X" and "V" are what we all know, so whilst vi is clearly superior, it's unfamiliar. Ergo, it is considered unfriendly. On no other basis, pure familiarity makes a Windows-like interface seem friendly. And as we learned in problem #1, GNU/Linux is necessarily different to Windows. Inescapably, GNU/Linux always appears less "user-friendly" than Windows.</p>
      <p>To avoid #5a problems, all you can really do is try and remember that <em>"user-friendly"</em> doesn't mean <em>"What I'm used to"</em>: try doing things your usual way, and if it doesn't work, try and work out what a total novice would do.</p>

      <h3>Subproblem #5b: Inefficient is friendly</h3>
      <p>This is a sad but inescapable fact. Paradoxically, the harder you make it to access an application's functionality, the friendlier it can seem to be.</p>
      <p>This is because friendliness is added to an interface by using simple, visible "clues"&mdash;the more, the better. After all, if a complete novice to computers is put in front of a <abbr title="What You See Is What You Get">WYSIWYG</abbr> word processor and asked to make a bit of text bold, which is more likely:</p>
      <ul class="browser-default">
        <li>He'll guess that "Ctrl-B" is the usual standard</li>
        <li>He'll look for clues, and try clicking on the "Edit" menu. Unsuccessful, he'll try the next likely one along the row of menus: "Format". The new menu has a "Font" option, which seems promising. And Hey! There's our "Bold" option. Success!</li>
      </ul>
      <p>Next time you do any processing, try doing every job via the menus: no shortcut keys, and no toolbar icons. Menus all the way. You'll find you slow to a crawl, as every task suddenly demands a multitude of keystrokes/mouseclicks.</p>
      <p>Making software "user-friendly" in this fashion is like putting training wheels on a bicycle: it lets you get up and running immediately, without any skill or experience needed. It's <em>perfect</em> for a beginner. But nobody out there thinks that <em>all</em> bicycles should be sold with training wheels: if you were given such a bicycle today, I'll wager the first thing you'd do is remove them for being unnecessary encumbrances. Once you know how to ride a bike, training wheels are unnecessary.</p>
      <p>And in the same way, a great deal of GNU/Linux software is designed without "training wheels" - it's designed for users who already have some basic skills in place. After all, nobody's a permanent novice. Ignorance is short-lived, and knowledge is forever. So the software is designed with the majority in mind.</p>
      <p>This might seem an excuse. After all, MS Word has all the friendly menus, <em>and</em> it has toolbar buttons, <em>and</em> it has shortcut keys... Best of all worlds, surely? Friendly <em>and</em> efficient.</p>
      <p>However, this has to be put into perspective. Firstly, the practicalities: having menus and toolbars and shortcuts and all would mean a lot of coding, and it's not like GNU/Linux developers all get paid for their time. Secondly, it still doesn't really take into account serious power-users. Very few professional wordsmiths use MS Word. Ever meet a coder who used MS Word? Compare that to how many use emacs and vi.</p>
      <p>Why is this? Firstly, because some "friendly" behaviour rules out efficient behaviour. See the "Cut and Copy" example above. And secondly, because most of Word's functionality is buried in menus that you <em>have</em> to use. Only the most common functionality has those handy little buttons in toolbars at the top. The less-used functions that are still vital for serious users just take too long to access.</p>
      <p>Something to bear in mind, however, is that "training wheels" are often available as "optional extras" for GNU/Linux software. They might not be obvious, but frequently they're available.</p>
      <p>Take mplayer. You use it to play a video file by typing <code>mplayer filename</code> in a terminal. You fastforward and rewind using the arrow keys and the PageUp and PageDown keys. This is not overly "user-friendly". However, if you instead type <code>gmplayer filename</code>, you'll get the graphical frontend, with all its nice, friendly, familiar buttons.</p>
      <p>Take ripping a CD to MP3 (or Ogg). Using the command-line, you need to use cdparanoia to rip the files to disc. Then you need an encoder... It's a hassle, even if you know exactly how to use the packages. So download and install something like Grip. This is an easy-to-use graphical frontend that uses cdparanoia and encoders behind-the-scenes to make it really easy to rip CDs, and even has CDDB support to name the files automatically for you.</p>
      <p>The same goes for ripping DVDs. The number of options to pass to transcode is a bit of a nightmare. But using dvd::rip to talk to transcode for you makes the whole thing a simple, GUI-based process which anybody can do.</p>
      <p>So to avoid #5b issues, remember that "training wheels" tend to be bolt-on extras in GNU/Linux, rather than being automatically supplied with the main product. And sometimes, "training wheels" just can't be part of the design.</p>

      <h2>Problem #6: Imitation vs. Convergence</h2>
      <p>An argument people often make when they find that GNU/Linux isn't the Windows clone they wanted is to insist that this is what GNU/Linux has been (or <em>should</em> have been) attempting to be since it was created, and that people who don't recognise this and help to make GNU/Linux more Windows-like are in the wrong. They draw on many arguments for this:</p>
      <blockquote>GNU/Linux has gone from command-line to graphics-based interfaces, a clear attempt to copy Windows</blockquote>
      <p>Nice theory, but false. The original X windowing system was released in 1984, as the successor to the W windowing system ported to Unix in 1983. Windows 1.0 was released in 1985. Windows didn't really make it big until version 3, released in 1990 - by which time, X windows had for years been at the X11 stage we use today. GNU/Linux itself was only started in 1991. So GNU/Linux didn't create a GUI to copy Windows. It simply made use of a GUI that existed long before Windows.</p>
      <blockquote>Windows 3 gave way to Windows 95 - making a huge level of changes to the UI that Microsoft has never equalled since. It had many new and innovative features: drag and drop functionality; taskbars, and so on. All of which have since been copied by GNU/Linux, of course.</blockquote>
      <p>Actually... no. All the above existed prior to Microsoft making use of them. NeXTSTeP in particular was a hugely advanced (for the time) GUI, and it predated Windows 95 significantly - version 1 released in 1989, and the final version in 1995.</p>
      <blockquote>Okay, so Microsoft didn't think up the individual features that we think of as the Windows Look-and-Feel. But it still created <em>a</em> Look-and-Feel, and GNU/Linux has been trying to imitate that ever since.</blockquote>
      <p>To debunk this, one must discuss the concept of <em>convergent evolution</em>. This is where two completely different and independent systems evolve over time to become very similar. It happens all the time in biology. For example, sharks and dolphins. Both are (typically) fish-eating marine organisms of about the same size. Both have dorsal fins, pectoral fins, tail fins, and similar, streamlined shapes.</p>
      <p>However, sharks evolved from fish, while dolphins evolved from a land-based quadrupedal mammal of some sort. The reason they have very similar overall appearances is that they both evolved to be as efficient as possible at living within a marine environment. At no stage did pre-dolphins (the relative newcomers) look at sharks and think <em>"Wow, look at those fins. They work really well. I'll try and evolve some myself!"</em></p>
      <p>Similarly, it's perfectly true to look at early GNU/Linux desktops and see FVWM and TWM and a lot of other simplistic GUIs. And then look at modern GNU/Linux desktops, and see Gnome and KDE with their taskbars and menus and eye-candy. And yes, it's true to say that they're a lot more like Windows than they used to be.</p>
      <p>But then, so is Windows. Windows 3.0 had no taskbar that I remember. And the Start menu? <em>What</em> Start menu?</p>
      <p>GNU/Linux didn't have a desktop anything like modern Windows. Microsoft didn't either. Now they both do. What does this tell us?</p>
      <p>It tells us that developers in both camps looked for ways of improving the GUI, and because there are only a limited number of solutions to a problem, they often used very similar methods. Similarity does not in any way prove or imply imitation. Remembering that will help you avoid straying into problem #6 territory.</p>

      <h2>Problem #7: That FOSS thing</h2>
      <p>Oh, this causes problems. Not intrinsically: the software being free and open-source is a wonderful and immensely important part of the whole thing. But understanding just how different FOSS is from proprietary software can be too big an adjustment for some people to make.</p>
      <p>I've already mentioned some instances of this: people thinking they can demand technical support and the like. But it goes far beyond that.</p>
      <p>Microsoft's Mission Statement is <i>"A computer on every desktop"</i>&mdash;with the unspoken rider that each computer should be running Windows. Microsoft and Apple both sell operating systems, and both do their utmost to make sure their products get used by the largest number of people: they're businesses, out to make money.</p>
      <p>And then there is FOSS. Which, even today, is almost entirely non-commercial.</p>
      <p>Before you reach for your email client to tell me about Red Hat, SUSE, Linspire and all: yes, I know they "sell" GNU/Linux. I know they'd all love GNU/Linux to be adopted universally, especially their own flavour of it. But don't confuse the suppliers with the manufacturers. The Linux kernel was not created by a company, and is not maintained by people out to make a profit with it. The GNU tools were not created by a company, and are not maintained by people out to make a profit with them. The X11 windowing system... well, the most popular implementation is X.Org right now, and the ".Org" part should tell you all you need to know. Desktop software: well, you might be able to make a case for KDE being commercial, since it's Qt-based. But Gnome, Fluxbox, Enlightenment, etc. are all non-profit. There <em>are</em> people out to sell GNU/Linux, but they are very much the minority.</p>
      <p>Increasing the number of end-users of proprietary software leads to a direct financial benefit to the company that makes it. This is simply not the case for FOSS: there is no direct benefit to any FOSS developer in increasing the userbase. Indirect benefits, yes: personal pride; an increased potential for finding bugs; more likelihood of attracting new developers; possibly a chance of a good job offer; and so on.</p>
      <p>But Linus Torvalds doesn't make money from increased GNU/Linux usage. Richard Stallman doesn't get money from increased GNU usage. All those servers running OpenBSD and OpenSSH don't put a penny into the OpenBSD project's pockets. And so we come to the biggest problem of all when it comes to new users and GNU/Linux:</p>
      <p>They find out they're not wanted.</p>
      <p>New users come to GNU/Linux after spending their lives using an operating system where the end-user's needs are paramount, and "user friendly" and "customer focus" are considered veritable Holy Grails. And they suddenly find themselves using an operating system that still relies on "man" files, the command-line, hand-edited configuration files, and Google. And when they complain, they don't get coddled or promised better things: they get bluntly shown the door.</p>
      <p>That's an exaggeration, of course. But it <em>is</em> how a lot of potential GNU/Linux converts perceived things when they tried and failed to make the switch.</p>
      <p>In an odd way, FOSS is actually a very selfish development method: people only work on what they want to work on, when they want to work on it. Most people don't see any need to make GNU/Linux more attractive to inexperienced end-users: it already does what <em>they</em> want it to do, why should they care if it doesn't work for other people? </p>
      <p>FOSS has many parallels with the Internet itself: you don't pay the writer of <strong>a webpage/the software</strong> to download and <strong>read/install</strong> it. <strong>Ubiquitous broadband/User-friendly interfaces</strong> are of no great interest to somebody who already <strong>has broadband/knows how to use the software</strong>. <strong>Bloggers/developers</strong> don't need to have lots of <strong>readers/users</strong> to justify <strong>blogging/coding</strong>. There <em>are</em> lots of people making lots of money off it, but it's not by the old-fashioned <em>"I own this and you have to pay me if you want some of it"</em> method that most businesses are so enamoured of; it's by providing services like <strong>tech-support/e-commerce</strong>.</p>
      <p>GNU/Linux is not interested in market share. GNU/Linux does not have customers. GNU/Linux does not have shareholders, or a responsibility to the bottom line. GNU/Linux was not created to make money. GNU/Linux does not have the goal of being the most popular and widespread operating system on the planet.</p>
      <p>All the GNU/Linux community wants is to create a really good, fully-featured, free operating system. If that results in GNU/Linux becoming a hugely popular operating system, then that's great. If that results in GNU/Linux having the most intuitive, user-friendly interface ever created, then that's great. If that results in GNU/Linux becoming the basis of a multi-billion dollar industry, then that's great.</p>
      <p>It's <em>great</em>, but it's not <em>the point</em>. The point is to make GNU/Linux the best operating system that the community is capable of making. Not for other people: for itself. The oh-so-common threats of <i>"GNU/Linux will never take over the desktop unless it does such-and-such"</i> are simply irrelevant: the GNU/Linux community isn't <em>trying</em> to take over the desktop. They really don't care if it gets good enough to make it onto <em>your</em> desktop, so long as it stays good enough to remain on <em>theirs</em>. The highly-vocal MS-haters, pro-GNU/Linux zealots, and money-making FOSS purveyors might be loud, but they're still minorities.</p>
      <p>That's what the GNU/Linux community wants: an operating system that can be installed by whoever really wants it. So if you're considering switching to GNU/Linux, first ask yourself what <em>you</em> really want.</p>
      <p>If you want an operating system that doesn't chauffeur you around, but hands you the keys, puts you in the driver's seat, <em>and expects you to know what to do</em>: <a href="<?php $this->base_url('switch_to_linux'); ?>">get&nbsp;GNU/Linux</a>. You'll have to devote some time to learning how to use it, but once you've done so, you'll have an operating system that you can make sit up and dance.</p>
      <p>If you really just want Windows without the malware and security issues: read up on good security practices; install a good firewall, malware-detector, and anti-virus; replace Internet Explorer with a more secure browser; and keep yourself up-to-date with security updates. There are people out there who've used Windows since 3.1 days right through to XP without ever being infected with a virus or malware: you can do it too. Don't get GNU/Linux; it will fail miserably at being what you want it to be.</p>
      <p>If you really want the security and performance of a Unix-based operating system but with a customer-focussed attitude and an world-renowned interface: buy an Apple Mac. macOS is great. But don't get GNU/Linux; it will not do what you want it to do.</p>
      <p>It's not just about <em>"Why should I want GNU/Linux?"</em>. It's also about <i>"Why should GNU/Linux want me?"</i></p>

      <hr>

      <p>This page is copyright 24/05/06 and belongs to Dominic Humphries. It may be redistributed under a <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/" rel="license external">Creative Commons License</a>.<br>
      The URL <a href="http://linux.oneandoneis2.org/LNW.htm" rel="external">http://linux.oneandoneis2.org/LNW.htm</a> must be supplied in attribution.</p>

      <br>

      <aside>
        <a class="waves-effect waves-light btn-large light-green darken-4" href="<?php $this->base_url('linux'); ?>">
          <?php print _("What is GNU/Linux?"); ?>
          <i class="material-icons <?php print $this->rtltr("left", "right"); ?>">expand_less</i>
        </a>
      </aside>

      <br>
    </div>
  </aside>
</main>

<?php $this->load_footer(); ?>
